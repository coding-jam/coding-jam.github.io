<!DOCTYPE html>
<html amp lang="en-US" i-amphtml-layout="" i-amphtml-no-boilerplate="" transformed="self;v=1">
<!-- Mirrored from codingjam.it/da-docker-compose-a-docker-swarm-viaggio-di-sola-andata/amp/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 04 Dec 2020 23:50:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8"><style amp-runtime="" i-amphtml-version="012011200012001">html{overflow-x:hidden!important}html.i-amphtml-fie{height:100%!important;width:100%!important}html:not([amp4ads]),html:not([amp4ads]) body{height:auto!important}html:not([amp4ads]) body{margin:0!important}body{-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%}html.i-amphtml-singledoc.i-amphtml-embedded{-ms-touch-action:pan-y;touch-action:pan-y}html.i-amphtml-fie>body,html.i-amphtml-singledoc>body{overflow:visible!important}html.i-amphtml-fie:not(.i-amphtml-inabox)>body,html.i-amphtml-singledoc:not(.i-amphtml-inabox)>body{position:relative!important}html.i-amphtml-webview>body{overflow-x:hidden!important;overflow-y:visible!important;min-height:100vh!important}html.i-amphtml-ios-embed-legacy>body{overflow-x:hidden!important;overflow-y:auto!important;position:absolute!important}html.i-amphtml-ios-embed{overflow-y:auto!important;position:static}#i-amphtml-wrapper{overflow-x:hidden!important;overflow-y:auto!important;position:absolute!important;top:0!important;left:0!important;right:0!important;bottom:0!important;margin:0!important;display:block!important}html.i-amphtml-ios-embed.i-amphtml-ios-overscroll,html.i-amphtml-ios-embed.i-amphtml-ios-overscroll>#i-amphtml-wrapper{-webkit-overflow-scrolling:touch!important}#i-amphtml-wrapper>body{position:relative!important;border-top:1px solid transparent!important}#i-amphtml-wrapper+body{visibility:visible}#i-amphtml-wrapper+body .i-amphtml-lightbox-element,#i-amphtml-wrapper+body[i-amphtml-lightbox]{visibility:hidden}#i-amphtml-wrapper+body[i-amphtml-lightbox] .i-amphtml-lightbox-element{visibility:visible}#i-amphtml-wrapper.i-amphtml-scroll-disabled,.i-amphtml-scroll-disabled{overflow-x:hidden!important;overflow-y:hidden!important}amp-instagram{padding:54px 0px 0px!important;background-color:#fff}amp-iframe iframe{box-sizing:border-box!important}[amp-access][amp-access-hide]{display:none}[subscriptions-dialog],body:not(.i-amphtml-subs-ready) [subscriptions-action],body:not(.i-amphtml-subs-ready) [subscriptions-section]{display:none!important}amp-experiment,amp-live-list>[update]{display:none}.i-amphtml-jank-meter{position:fixed;background-color:rgba(232,72,95,0.5);bottom:0;right:0;color:#fff;font-size:16px;z-index:1000;padding:5px}amp-list[resizable-children]>.i-amphtml-loading-container.amp-hidden{display:none!important}amp-list [fetch-error],amp-list[load-more] [load-more-button],amp-list[load-more] [load-more-end],amp-list[load-more] [load-more-failed],amp-list[load-more] [load-more-loading]{display:none}amp-list[diffable] div[role=list]{display:block}amp-story-page,amp-story[standalone]{min-height:1px!important;display:block!important;height:100%!important;margin:0!important;padding:0!important;overflow:hidden!important;width:100%!important}amp-story[standalone]{background-color:#202125!important;position:relative!important}amp-story-page{background-color:#757575}amp-story .amp-active>div,amp-story .i-amphtml-loader-background{display:none!important}amp-story-page:not(:first-of-type):not([distance]):not([active]){transform:translateY(1000vh)!important}amp-autocomplete{position:relative!important;display:inline-block!important}amp-autocomplete>input,amp-autocomplete>textarea{padding:0.5rem;border:1px solid rgba(0,0,0,0.33)}.i-amphtml-autocomplete-results,amp-autocomplete>input,amp-autocomplete>textarea{font-size:1rem;line-height:1.5rem}[amp-fx^=fly-in]{visibility:hidden}amp-script[nodom]{position:fixed!important;top:0!important;width:1px!important;height:1px!important;overflow:hidden!important;visibility:hidden}
/*# sourceURL=/css/ampdoc.css*/[hidden]{display:none!important}.i-amphtml-element{display:inline-block}.i-amphtml-blurry-placeholder{transition:opacity 0.3s cubic-bezier(0.0,0.0,0.2,1)!important;pointer-events:none}[layout=nodisplay]:not(.i-amphtml-element){display:none!important}.i-amphtml-layout-fixed,[layout=fixed][width][height]:not(.i-amphtml-layout-fixed){display:inline-block;position:relative}.i-amphtml-layout-responsive,[layout=responsive][width][height]:not(.i-amphtml-layout-responsive),[width][height][heights]:not([layout]):not(.i-amphtml-layout-responsive),[width][height][sizes]:not([layout]):not(.i-amphtml-layout-responsive){display:block;position:relative}.i-amphtml-layout-intrinsic,[layout=intrinsic][width][height]:not(.i-amphtml-layout-intrinsic){display:inline-block;position:relative;max-width:100%}.i-amphtml-layout-intrinsic .i-amphtml-sizer{max-width:100%}.i-amphtml-intrinsic-sizer{max-width:100%;display:block!important}.i-amphtml-layout-container,.i-amphtml-layout-fixed-height,[layout=container],[layout=fixed-height][height]:not(.i-amphtml-layout-fixed-height){display:block;position:relative}.i-amphtml-layout-fill,.i-amphtml-layout-fill.i-amphtml-notbuilt,[layout=fill]:not(.i-amphtml-layout-fill){display:block;overflow:hidden!important;position:absolute;top:0;left:0;bottom:0;right:0}.i-amphtml-layout-flex-item,[layout=flex-item]:not(.i-amphtml-layout-flex-item){display:block;position:relative;-ms-flex:1 1 auto;flex:1 1 auto}.i-amphtml-layout-fluid{position:relative}.i-amphtml-layout-size-defined{overflow:hidden!important}.i-amphtml-layout-awaiting-size{position:absolute!important;top:auto!important;bottom:auto!important}i-amphtml-sizer{display:block!important}@supports (aspect-ratio:1/1){i-amphtml-sizer.i-amphtml-disable-for-ar{display:none!important}}.i-amphtml-blurry-placeholder,.i-amphtml-fill-content{display:block;height:0;max-height:100%;max-width:100%;min-height:100%;min-width:100%;width:0;margin:auto}.i-amphtml-layout-size-defined .i-amphtml-fill-content{position:absolute;top:0;left:0;bottom:0;right:0}.i-amphtml-replaced-content,.i-amphtml-screen-reader{padding:0!important;border:none!important}.i-amphtml-screen-reader{position:fixed!important;top:0px!important;left:0px!important;width:4px!important;height:4px!important;opacity:0!important;overflow:hidden!important;margin:0!important;display:block!important;visibility:visible!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:8px!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:12px!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:16px!important}.i-amphtml-unresolved{position:relative;overflow:hidden!important}.i-amphtml-select-disabled{-webkit-user-select:none!important;-ms-user-select:none!important;user-select:none!important}.i-amphtml-notbuilt,[layout]:not(.i-amphtml-element),[width][height][heights]:not([layout]):not(.i-amphtml-element),[width][height][sizes]:not([layout]):not(.i-amphtml-element){position:relative;overflow:hidden!important;color:transparent!important}.i-amphtml-notbuilt:not(.i-amphtml-layout-container)>*,[layout]:not([layout=container]):not(.i-amphtml-element)>*,[width][height][heights]:not([layout]):not(.i-amphtml-element)>*,[width][height][sizes]:not([layout]):not(.i-amphtml-element)>*{display:none}amp-img:not(.i-amphtml-element)[i-amphtml-ssr]>img.i-amphtml-fill-content{display:block}.i-amphtml-notbuilt:not(.i-amphtml-layout-container),[layout]:not([layout=container]):not(.i-amphtml-element),[width][height][heights]:not([layout]):not(.i-amphtml-element),[width][height][sizes]:not([layout]):not(.i-amphtml-element){color:transparent!important;line-height:0!important}.i-amphtml-ghost{visibility:hidden!important}.i-amphtml-element>[placeholder],[layout]:not(.i-amphtml-element)>[placeholder],[width][height][heights]:not([layout]):not(.i-amphtml-element)>[placeholder],[width][height][sizes]:not([layout]):not(.i-amphtml-element)>[placeholder]{display:block}.i-amphtml-element>[placeholder].amp-hidden,.i-amphtml-element>[placeholder].hidden{visibility:hidden}.i-amphtml-element:not(.amp-notsupported)>[fallback],.i-amphtml-layout-container>[placeholder].amp-hidden,.i-amphtml-layout-container>[placeholder].hidden{display:none}.i-amphtml-layout-size-defined>[fallback],.i-amphtml-layout-size-defined>[placeholder]{position:absolute!important;top:0!important;left:0!important;right:0!important;bottom:0!important;z-index:1}.i-amphtml-notbuilt>[placeholder]{display:block!important}.i-amphtml-hidden-by-media-query{display:none!important}.i-amphtml-element-error{background:red!important;color:#fff!important;position:relative!important}.i-amphtml-element-error:before{content:attr(error-message)}i-amp-scroll-container,i-amphtml-scroll-container{position:absolute;top:0;left:0;right:0;bottom:0;display:block}i-amp-scroll-container.amp-active,i-amphtml-scroll-container.amp-active{overflow:auto;-webkit-overflow-scrolling:touch}.i-amphtml-loading-container{display:block!important;pointer-events:none;z-index:1}.i-amphtml-notbuilt>.i-amphtml-loading-container{display:block!important}.i-amphtml-loading-container.amp-hidden{visibility:hidden}.i-amphtml-element>[overflow]{cursor:pointer;position:relative;z-index:2;visibility:hidden;display:initial;line-height:normal}.i-amphtml-element>[overflow].amp-visible{visibility:visible}template{display:none!important}.amp-border-box,.amp-border-box *,.amp-border-box :after,.amp-border-box :before{box-sizing:border-box}amp-pixel{display:none!important}amp-analytics,amp-auto-ads,amp-story-auto-ads{position:fixed!important;top:0!important;width:1px!important;height:1px!important;overflow:hidden!important;visibility:hidden}html.i-amphtml-fie>amp-analytics{position:initial!important}[visible-when-invalid]:not(.visible),form [submit-error],form [submit-success],form [submitting]{display:none}amp-accordion{display:block!important}amp-accordion>section{float:none!important}amp-accordion>section>*{float:none!important;display:block!important;overflow:hidden!important;position:relative!important}amp-accordion,amp-accordion>section{margin:0}amp-accordion:not(.i-amphtml-built)>section>:last-child{display:none!important}amp-accordion:not(.i-amphtml-built)>section[expanded]>:last-child{display:block!important}
/*# sourceURL=/css/ampshared.css*/</style><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"><meta name="generator" content="AMP Plugin v1.5.3; mode=reader"><meta name="generator" content="WordPress 5.4.1"><title>Da Docker Compose a Docker Swarm: viaggio di sola andata? – CodingJam</title><link rel="preconnect" href="https://cdn.ampproject.org/"><link rel="preload" as="script" href="https://cdn.ampproject.org/v0.js"><script async="" src="https://cdn.ampproject.org/v0.js"></script><style amp-custom="">.wp-block-image{margin-bottom:1em}.wp-block-image amp-img{max-width:100%}.wp-block-image .alignleft,.wp-block-image.is-resized{display:table}.wp-block-image .alignleft{float:left;margin:.5em 1em .5em 0}.wp-block-quote{border-left:4px solid #000;margin:0 0 28px;padding-left:1em}.wp-block-quote footer{color:#6c7781;font-size:13px;margin-top:1em;position:relative;font-style:normal}.alignleft{margin-top:1em;margin-right:auto;margin-bottom:1em;margin-left:auto}.alignleft{float:left}.amp-wp-enforced-sizes{max-width:100%;margin:0 auto}amp-img.amp-wp-enforced-sizes[layout="intrinsic"] > img{object-fit:contain}html{background:#0a89c0}body{background:#fff;color:#353535;font-family:Georgia,"Times New Roman",Times,Serif;font-weight:300;line-height:1.75em}p,ul,figure{margin:0 0 1em;padding:0}a,a:visited{color:#0a89c0}a:hover,a:active,a:focus{color:#353535}blockquote{color:#353535;background:rgba(127,127,127,.125);border-left:2px solid #0a89c0;margin:8px 0 24px 0;padding:16px}blockquote p:last-child{margin-bottom:0}.amp-wp-meta,.amp-wp-header div,.amp-wp-title,.amp-wp-tax-category,.amp-wp-tax-tag,.amp-wp-comments-link,.amp-wp-footer p,.back-to-top{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen-Sans","Ubuntu","Cantarell","Helvetica Neue",sans-serif}.amp-wp-header{background-color:#0a89c0}.amp-wp-header div{color:#fff;font-size:1em;font-weight:400;margin:0 auto;max-width:calc(840px - 32px);padding:.875em 16px;position:relative}.amp-wp-header a{color:#fff;text-decoration:none}.amp-wp-header .amp-wp-site-icon{background-color:#fff;border:1px solid #fff;border-radius:50%;position:absolute;right:18px;top:10px}.amp-wp-article{color:#353535;font-weight:400;margin:1.5em auto;max-width:840px;overflow-wrap:break-word;word-wrap:break-word}.amp-wp-article-header{align-items:center;align-content:stretch;display:flex;flex-wrap:wrap;justify-content:space-between;margin:1.5em 16px 0}.amp-wp-title{color:#353535;display:block;flex:1 0 100%;font-weight:900;margin:0 0 .625em;width:100%}.amp-wp-meta{color:#696969;display:inline-block;flex:2 1 50%;font-size:.875em;line-height:1.5em;margin:0 0 1.5em;padding:0}.amp-wp-article-header .amp-wp-meta:last-of-type{text-align:right}.amp-wp-article-header .amp-wp-meta:first-of-type{text-align:left}.amp-wp-byline amp-img,.amp-wp-byline .amp-wp-author{display:inline-block;vertical-align:middle}.amp-wp-byline amp-img{border:1px solid #0a89c0;border-radius:50%;position:relative;margin-right:6px}.amp-wp-posted-on{text-align:right}.amp-wp-article-content{margin:0 16px}.amp-wp-article-content ul{margin-left:1em}.amp-wp-article-content amp-img{margin:0 auto}.amp-wp-article-content amp-img.alignleft{margin:0 16px 1em 0}.amp-wp-article-footer .amp-wp-meta{display:block}.amp-wp-tax-category,.amp-wp-tax-tag{color:#696969;font-size:.875em;line-height:1.5em;margin:1.5em 16px}.amp-wp-comments-link{color:#696969;font-size:.875em;line-height:1.5em;text-align:center;margin:2.25em 0 1.5em}.amp-wp-comments-link a{border-style:solid;border-color:#c2c2c2;border-width:1px 1px 2px;border-radius:4px;background-color:transparent;color:#0a89c0;cursor:pointer;display:block;font-size:14px;font-weight:600;line-height:18px;margin:0 auto;max-width:200px;padding:11px 16px;text-decoration:none;width:50%;-webkit-transition:background-color .2s ease;transition:background-color .2s ease}.amp-wp-footer{border-top:1px solid #c2c2c2;margin:calc(1.5em - 1px) 0 0}.amp-wp-footer div{margin:0 auto;max-width:calc(840px - 32px);padding:1.25em 16px 1.25em;position:relative}.amp-wp-footer h2{font-size:1em;line-height:1.375em;margin:0 0 .5em}.amp-wp-footer p{color:#696969;font-size:.8em;line-height:1.5em;margin:0 85px 0 0}.amp-wp-footer a{text-decoration:none}.back-to-top{bottom:1.275em;font-size:.8em;font-weight:600;line-height:2em;position:absolute;right:16px}:root:not(#_):not(#_):not(#_):not(#_):not(#_) .amp-wp-276eb22{font-size:18px}

/*# sourceURL=amp-custom.css */</style><link rel="canonical" href="../index.html"><script type="application/ld+json">{"@context":"http:\/\/schema.org","publisher":{"@type":"Organization","name":"CodingJam","logo":"https:\/\/codingjam.it\/wp-content\/uploads\/2018\/09\/cropped-logo-cnj-bianco.png"},"@type":"BlogPosting","mainEntityOfPage":"https:\/\/codingjam.it\/da-docker-compose-a-docker-swarm-viaggio-di-sola-andata\/","headline":"Da Docker Compose a Docker Swarm: viaggio di sola andata?","datePublished":"2019-05-06T08:02:05+02:00","dateModified":"2019-04-22T15:13:00+02:00","author":{"@type":"Person","name":"Andrea Como"},"image":"https:\/\/codingjam.it\/wp-content\/uploads\/2019\/04\/ingress-routing-mesh.png"}</script></head><body class="">

<header id="top" class="amp-wp-header"><div>
		<a href="../../index.html">
										<amp-img src="../../wp-content/uploads/2018/09/cropped-codingjam-jar-transp-white-big-512-32x32.png" width="32" height="32" class="amp-wp-site-icon i-amphtml-layout-fixed i-amphtml-layout-size-defined" style="width:32px;height:32px;" i-amphtml-layout="fixed"></amp-img><span class="amp-site-title">
				CodingJam			</span>
		</a>

					</div>
</header><article class="amp-wp-article"><header class="amp-wp-article-header"><h1 class="amp-wp-title">Da Docker Compose a Docker Swarm: viaggio di sola andata?</h1>
			<div class="amp-wp-meta amp-wp-byline">
					<amp-img src="https://secure.gravatar.com/avatar/684ede46c9386ff5430335a42fd5b011?s=24&amp;d=mm&amp;r=g" alt="Andrea Como" width="24" height="24" layout="fixed" class="i-amphtml-layout-fixed i-amphtml-layout-size-defined" style="width:24px;height:24px;" i-amphtml-layout="fixed"></amp-img><span class="amp-wp-author author vcard">Andrea Como</span>
	</div>
<div class="amp-wp-meta amp-wp-posted-on">
	<time datetime="2019-05-06T10:02:05+00:00">
		2 years ago	</time></div>
	</header><div class="amp-wp-article-content">
		
<p>Sin dalle prime ore di uso di Docker, si sente subito la necessità di <em>salvare in qualche formato</em>, che non sia uno script bash, i mille parametri che si possono passare al comando <tt>docker run</tt>. Ben presto si fa la conoscenza di <strong><a href="https://docs.docker.com/compose/" target="_blank">Docker Compose</a></strong>: avere un file YAML che descrive i parametri di lancio, ma non solo, di uno o più container ci fa sentire al sicuro perché possiamo metterlo sotto controllo di versione. Appena però abbiamo bisogno di far girare i container su più macchine, ci rendiamo conto che nemmeno questo è lo strumento che stavamo cercando. Abbiamo bisogno di <strong><a href="https://docs.docker.com/engine/swarm/" target="_blank">Docker Swarm</a></strong> per fare questo e, da tre anni ormai dalla sua nascita, possiamo considerarlo ormai <em>production-ready</em>.</p>



<p>Se siete qua, probabilmente sapete già cosa sono Compose e Swarm e magari vi state chiedendo se conviene fare un “upgrade”. Cerchiamo insieme di capire se si tratta davvero di un upgrade e cosa comporta.</p>



<h2>Docker Compose</h2>



<blockquote class="wp-block-quote amp-wp-276eb22" data-amp-original-style="font-size: 18px"><p>Compose è uno strumento per definire ed eseguire applicazioni Docker multi-container. Con Compose, è possibile definire un file YAML per configurare i servizi applicativi.</p></blockquote>



<p>Nel file YAML infatti, è possibile definire più container Docker sotto il cappello “<em>services</em>“, sia <strong>a partire da </strong><tt><strong>Dockerfile</strong></tt> che da <strong>immagini già pronte</strong>.</p>



<h3>Docker Compose all’opera</h3>



<p>Immaginiamo di voler tirare su WordPress, che ha bisogno di MySQL. All’interno di una cartella chiamata <tt>wordpress-docker</tt>, creiamo un file di nome <tt>docker-compose.yml</tt> con questo contenuto (presente su <a href="https://github.com/coding-jam/wordpress-docker-poc" target="_blank" rel="noreferrer noopener" aria-label="GitHub (opens in a new tab)">GitHub</a>):</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">version: '3.7'

services:
   db:
     build: ./mysql
     image: poc/mysql-for-wordpress
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: somewordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     ports:
       - "8000:80"
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD: wordpress
       WORDPRESS_DB_NAME: wordpress
volumes:
    db_data: {}</pre>



<p>In questo caso abbiamo fatto una personalizzazione (non che ce ne fosse bisogno, è solo a scopo didattico), tramite <tt>Dockerfile</tt>, del container di MySQL, mentre abbiamo preso quello di default per WordPress. Da notare il valore di <tt>WORDPRESS_DB_HOST</tt> “<tt>db:3306</tt>“: il riferimento al container del database viene risolto con il <strong>nome del servizio associato</strong>.</p>



<p>Docker Compose però <em>non è nativamente disponibile</em> quando si installa Docker, ma è un tool separato, scritto in Python, che <a rel="noreferrer noopener" aria-label="va installato autonomamente (opens in a new tab)" href="https://docs.docker.com/compose/install/" target="_blank">va installato autonomamente</a> e <strong>automatizza certe operazioni</strong> del demone Docker. Ha una propria CLI, accessibile tramite il comando <tt>docker-compose</tt>, che semplifica notevolmente la “gestione di gruppo” dei servizi elencati nel file YAML.</p>



<p>Per avviare tutti i servizi, basta eseguire:</p>



<pre>$&gt; docker-compose up -d
</pre>



<p>Dove con <tt>-d</tt> si evita di rimanere attaccati al <em>system out</em> dei container avviati. Cosa accade adesso? Il controllo della console ci viene restituito <strong>solo dopo</strong> queste operazioni:</p>



<pre>Creating network "wordpress-docker_default" with the default driver
Creating volume "wordpress-docker_db_data" with default driver
Building db
Step 1/2 : FROM mysql:5.7
 ---&gt; 98455b9624a9
Step 2/2 : COPY *.cnf /etc/mysql/conf.d/
 ---&gt; 52440b13db7c

Successfully built 52440b13db7c
Successfully tagged poc/mysql-for-wordpress:latest
WARNING: Image for service db was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating wordpress-docker_db_1 ... done
Creating wordpress-docker_wordpress_1 ... done
</pre>



<ul><li>viene creato un network che <strong>lega i due container</strong> e <strong>li isola da tutto il resto</strong>. Il nome è curioso: si tratta del nome della cartella dove risiede il <tt>docker-compose.yml</tt> (chiamata <tt>wordpress-docker</tt> ricordate?) a cui viene apposto “default”.</li><li>viene creato il volume “db_data”, sempre con prefisso <tt>wordpress-docker</tt>.</li><li>viene creata l’<strong>immagine modificata del database</strong>, chiamata <tt>poc/mysql-for-wordpress</tt>, tramite il <tt>Dockerfile</tt> presente nella cartella <tt>mysql</tt>.</li><li>vengono <strong>avviati i container</strong> dei servizi “db” e “wordpress”, esattamente in quest’ordine, per via delle dipendenze. In questo caso, oltre al consueto prefisso <tt>wordpress-docker</tt>, notiamo un numero dopo che segue il nome del servizio: si tratta della prima istanza del servizio.</li></ul><p>La prima cosa che salta all’occhio è che il <strong>nome della cartella</strong> che contiene il file YAML viene usata come “<em><strong>namespace</strong></em>” per la nomenclatura delle risorse create: questo approccio è interessante perché permette di rilanciare lo stesso stack di servizi da cartelle diverse senza creare conflitti.</p>



<p>Tutte queste operazioni sono <strong>sincrone</strong> con la CLI: finché i container non saranno avviati, non potremo riprendere il controllo della console. La CLI di compose è interessante perché permette di controllare in gruppo i container:</p>



<pre>$&gt; docker-compose ps

            Name                          Command               State          Ports
--------------------------------------------------------------------------------------------
wordpress-docker_db_1          docker-entrypoint.sh mysqld      Up      3306/tcp, 33060/tcp
wordpress-docker_wordpress_1   docker-entrypoint.sh apach ...   Up      0.0.0.0:8000-&gt;80/tcp
</pre>



<p>visualizza lo <strong>stato dei container</strong> e le <strong>relative porte mappate</strong> (se ci sono). E’ possibile anche controllarne uno solo, chiamato con il nome del servizio:</p>



<pre>$&gt; docker-compose stop wordpress
Stopping wordpress-docker_wordpress_1 ... done

$&gt; docker-compose start wordpress
Starting wordpress ... done
</pre>



<p>Se si riesegue il comando di avvio di tutti i servizi (<tt>up</tt>), Compose controllerà per noi <strong>se esistono versioni nuove delle immagini</strong> ed eventualmente le <strong>avvierà</strong> (con le dipendenze in cascata). Modificando l’immagine del database quindi, verrà riavviato anche WordPress:</p>



<pre>$&gt; docker-compose up -d
Recreating wordpress-docker_db_1 ... done
Recreating wordpress-docker_wordpress_1 ... done
</pre>



<h3>Tirando le somme</h3>



<p>Fin qua abbiamo visto che Compose è perfetto per gestire il ciclo di <strong>build</strong> e di <strong>runtime</strong> di più servizi insieme, perché dovremmo avere bisogno di altro? </p>



<p>Per il supporto allo sviluppo software è perfetto: possiamo praticamente creare e tirare su l’infrastruttura di cui abbiamo bisogno sulla nostra macchina di sviluppo! A mio avviso, Compose comincia a stare stretto in due casi:</p>



<ul><li>quando si ha bisogno che i servizi <strong>girino su più macchine</strong>, Compose <strong>non</strong> è in grado di controllare questa situazione. La rete che viene creata tra i servizi istanziati è una sottorete dello <strong>stesso host,</strong> puro isolamento basato su <tt>iptables</tt>: non esiste un concetto di “cluster di nodi”. Non possiamo quindi far girare WordPress su una macchina e il MySQL in un’altra gestiti da Compose, perché non si “vedrebbero” a livello di rete: i Compose delle due macchine non avrebbero niente in comune. L’unico modo per farli comunicare sarebbe esporre le porte sui rispettivi host e far dialogare i servizi tramite gli hostname, ma si perde tutta la dinamicità offerta da Docker.</li><li>se si prova a <strong>scalare un servizio</strong> (ovviamente sullo stesso host perché non si può fare altrimenti) che ha il <em>binding</em> di una porta sull’host, lo <strong>scaling verrà impedito</strong> perché la porta è già occupata dalla prima istanza! Proviamo infatti a scalare WordPress: 

<pre>$&gt; docker-compose up -d --scale wordpress=2  
WARNING: The "wordpress" service specifies a port on the host. If multiple containers for this service are created on a single host, the port will clash.  
Starting wordpress-docker_wordpress_1 ... done  
Creating wordpress-docker_wordpress_2 ... error  
ERROR: for wordpress-docker_wordpress_2  Cannot start service wordpress: driver failed programming external connectivity on endpoint wordpress-docker_wordpress_2 (f19636f06cfcf461c0d175a182fa3b7f53bf0f9c430260e76320f7bfa31f9220): Bind for 0.0.0.0:8000 failed: port is already allocated </pre>

Volendo scalare il database, invece, questo funzionerebbe perché non ha binding: 

<pre>$&gt; docker-compose up -d --scale db=2 
Starting wordpress-docker_db_1 ... done 
Creating wordpress-docker_db_2 ... done 
wordpress-docker_wordpress_1 is up-to-date 
</pre> 

Anche se poi il risultato è che 2 istanze di MySQL sullo stesso volume possono solo fare danni :), quindi meglio evitare! </li></ul><p>Quando si ha la necessità di controllare più servizi su più macchine, e magari scalarli su di esse, è necessario qualcosa di più, è necessario almeno <strong>Docker Swarm</strong>. Prima di continuare, distruggiamo tutti i container, compresi i volumi:</p>



<pre>$&gt; docker-compose down -v
Stopping wordpress-docker_wordpress_1 ... done
Stopping wordpress-docker_db_1        ... done
Removing wordpress-docker_wordpress_1 ... done
Removing wordpress-docker_db_1        ... done
Removing network wordpress-docker_default
Removing volume wordpress-docker_db_data
</pre>



<h2>Docker Swarm</h2>



<blockquote class="wp-block-quote amp-wp-276eb22" data-amp-original-style="font-size: 18px"><p>Uno swarm (“sciame” in italiano) consiste in un <strong>insieme di <strong>nodi</strong> Docker</strong> che si comportano da <em>manager, </em>per la gestione del cluster stesso, e <em>worker</em>, che eseguono <strong>servizi</strong>.</p></blockquote>



<p>Swarm si propone quindi come lo strumento di default per la <em>gestione di container in un cluster di nodi Docker</em>.  </p>



<h3>Un po’ di teoria</h3>



<p>Già dalla definizione, emergono una serie di <a rel="noreferrer noopener" aria-label="concetti e terminologie (opens in a new tab)" href="https://docs.docker.com/engine/swarm/key-concepts" target="_blank">concetti e terminologie</a> che è bene avere chiari prima di andare avanti:</p>



<ul><li><strong><em>nodi</em></strong>: si tratta di <strong>istanze di Docker</strong> che partecipano al cluster. Solitamente, ogni istanza del motore di Docker risiede su <em>una</em> macchina fisica o virtuale che sia: di conseguenza si può pensare (ma non è obbligatorio) ad un nodo dello swarm come ad una macchina. I nodi possono essere di tipo <strong><em>manager</em></strong> o <strong><em>worker</em> </strong>(o <strong>entrambi</strong>): più nodi possono avere il ruolo di master, ma solo uno è eletto in un certo momento a coordinare i servizi e a mantenere lo stato del cluster. Il <strong>deploy</strong> di una applicazione <strong>passa sempre da un nodo master</strong> che <strong>delega un </strong><em><strong>task</strong></em><strong> ad un nodo worker</strong> (o un altro master, o a se stesso) in modo che <em>esegua il servizio richiesto</em>. I nodi del cluster informano sempre il nodo master sullo stato dei task assegnati, in modo da mantenere sempre lo stato dei servizi come richiesto.</li><li><strong><em>task</em></strong> e <strong><em>servizi</em></strong>: abbiamo visto che un nodo master assegna il compito (<em>task</em> appunto) di eseguire un certo <em>servizio</em> su un nodo del cluster (possibilmente worker), ovvero avviare una o più istanze di un container a partire da una immagine. Questo concetto già ci suona più familiare: servizi e container li avevamo visti anche con Compose. Ma questo task invece? Come vedremo a breve, è un concetto abbastanza trasparente, ma fondamentale, nell’uso di Swarm, se non per il fatto che tutta l’interazione tra il nodo master e la CLI è <strong>asincrona</strong>: da qua si evince che c’è qualcuno che sta facendo qualcosa (task) dopo che abbiamo eseguito un comando.</li></ul><h3>Docker Swarm all’opera</h3>



<p>Swarm <em>non è attivo di default</em>, anche se <strong>è già disponibile</strong> nell’installazione di Docker (a differenza del Compose). Dobbiamo quindi solo decidere come attivarlo: per lo <em>sviluppo</em>, cioè sulla <em>nostra macchina</em>, possiamo fare un <strong>cluster di un nodo</strong> semplicemente digitando:</p>



<pre>$&gt; docker swarm init
Swarm initialized: current node (keiak51s53xowk57oq24bd5yi) is now a manager.
</pre>



<p>Docker entra in <strong>modalità Swarm</strong> e considera se stesso un <strong>nodo master</strong>. L’output completo del comando (qua omesso) dà anche istruzioni su come <a rel="noreferrer noopener" aria-label="aggiungere altri nodi (opens in a new tab)" href="https://docs.docker.com/engine/reference/commandline/swarm_join/" target="_blank">aggiungere altri nodi</a> al cluster (sia master che worker). Tramite i comandi della CLI <tt>docker swarm</tt> e <tt>docker node</tt> è possibile gestire il cluster.</p>



<p>Ma torniamo a ciò che ci interessa: può Swarm aiutarci a superare i limiti che abbiamo visto con Compose? Essendo al momento su un singolo nodo, non noteremo grandi differenze, se non per il fatto che <strong>adesso lo scaling funzionerà</strong>!! Ma andiamo per gradi.</p>



<h4>Docker stacks</h4>



<p>Nel gergo Swarm, l’insieme dei servizi che possiamo deployare si chiama “<strong>stack</strong>“, cioè pila di servizi. La cosa scaltra di Swarm è che <strong>usa i file YAML di Compose</strong>, quindi il <em>passaggio a Swarm è molto semplice</em> (anzi, si è quasi invogliati): basta riusare lo <strong>stesso identico file di prima</strong> e deployare lo stack così:</p>



<pre>$&gt; docker stack deploy -c docker-compose.yml wp
Ignoring unsupported options: build, restart

Creating network wp_default
Creating service wp_db
Creating service wp_wordpress
</pre>



<p>Senza sapere né leggere né scrivere notiamo che:</p>



<ul><li>Il comando <tt>stack deploy</tt> vuole per forza il riferimento al file YAML e il <strong>nome dello stack</strong> da creare. Il nome è usato come <em>prefisso</em> per le risorse create: il servizio WordPress, il database e la network che li isola. Fossimo un un cluster con più nodi, questa network <strong>sarebbe accessibile anche cross-nodo</strong> se i due container fossero su nodi diversi.</li><li>Le direttive <tt>build</tt> e <tt>restart</tt> sono state ignorate! Questo significa che <strong>non posso eseguire le build</strong> delle immagini con Swarm?! Ebbene è proprio così! Come direbbe Doc: “<em>Marty, non stai pensando quadrimensionalmente!</em>” Che senso avrebbe creare immagini su un nodo se poi non è detto che vengano eseguite li? Come portarle sugli altri nodi? Il problema non si pone: <strong>Swarm è un ambiente di runtime</strong>: qualcun altro deve essere responsabile di fornirgli le immagini già pronte. E <tt>restart</tt> invece perché viene ignorato? A dirla tutta, Swarm e Compose usano dialetti leggermente diversi del descrittore YAML (in base alla versione): questo discorso lo accenniamo più avanti.</li></ul><p>La CLI ha restituito subito il controllo, significa che <em>qualcuno sta facendo qualcosa</em> (ricordate i task?) in <em>background</em> (magari su un altra macchina nel caso multi-nodo). L’interazione è quindi <strong>asincrona</strong>: come si fa a vedere cosa sta succedendo? Il comando </p>



<pre class="wp-block-preformatted">$&gt; docker stack ps wp <br>ID                  NAME                IMAGE                            NODE                    DESIRED STATE       CURRENT STATE            ERROR               PORTS <br>tlobb6t4vnxo        wp_wordpress.1      wordpress:latest                 linuxkit-025000000001   Running             Running 2 minutes ago <br>uvxb7yhbdu1v        wp_db.1             poc/mysql-for-wordpress:latest   linuxkit-025000000001   Running             Running 2 minutes ago</pre>



<p>ci dà una panoramica dello <strong>stato dei task</strong> di <tt>wp</tt>: abbiamo quindi un task per ogni istanza (per questo il numerino in fondo al nome) di container che implementa il servizio richiesto. Chi li ha istruiti a comportarsi così? Per capire, dobbiamo approfondire il concetto di <strong>servizio</strong>.</p>



<h4>Docker services</h4>



<p>In Compose si parla di servizi: ci appaiono come dei <em>proxy sul container</em> (o le sue repliche) gestite dal Compose. In Swarm questo concetto è reso più forte ed assume un ruolo centrale, diventando di fatto l’<strong><em>unità di deployment</em></strong>.</p>



<div class="wp-block-image"><figure class="alignleft is-resized"><amp-img src="../../wp-content/uploads/2019/04/services-diagram.png" alt="services-diagram" class="wp-image-17978 amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" width="396" height="272" srcset="https://codingjam.it/wp-content/uploads/2019/04/services-diagram.png 800w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-300x207.png 300w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-768x530.png 768w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-150x104.png 150w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-683x471.png 683w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-706x487.png 706w" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg height=&quot;272&quot; width=&quot;396&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;/>"></i-amphtml-sizer><noscript><img src="../../wp-content/uploads/2019/04/services-diagram.png" alt="services-diagram" class="wp-image-17978" width="396" height="272" srcset="https://codingjam.it/wp-content/uploads/2019/04/services-diagram.png 800w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-300x207.png 300w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-768x530.png 768w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-150x104.png 150w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-683x471.png 683w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-706x487.png 706w" sizes="(max-width: 396px) 100vw, 396px"></noscript></amp-img></figure></div>



<p>Quando infatti si <strong>deploya una applicazione, in realtà si chiede (al master) di creare un servizio</strong>, il cui <strong>stato desiderato</strong> (immagine da usare, porte esposte, overlay di rete…) è definito nel file YAML. Dalla richiesta di servizio si <strong>generano</strong> (in gergo si “schedulano”) quindi i task che istanziano i container nel cluster, in modo da “implementare” lo stato desiderato. Vediamo allora i servizi generati dal nostro stack <tt>wp</tt>:</p>



<pre>$ docker stack services wp
ID                  NAME                MODE                REPLICAS            IMAGE                            PORTS
bo6cdv2jwnqz        wp_db               replicated          1/1                 poc/mysql-for-wordpress:latest
klsaic86xu39        wp_wordpress        replicated          1/1                 wordpress:latest                 *:8000-&gt;80/tcp
</pre>



<p>Notiamo che abbiamo <em>una replica</em> rispettivamente del database e di WordPress (corrispondenti ai task), nonché il <em>binding</em> della porta 80 di quest’ultimo sulla 8000 dell’host. Adesso siamo in condizioni di<strong> poter scalare il container di WordPress</strong> a due repliche (anche perché è l’unico che ha senso) senza avere problemi:</p>



<pre>$&gt; docker service scale wp_wordpress=2
wp_wordpress scaled to 2
overall progress: 2 out of 2 tasks
1/2: running   [==================================================&gt;]
2/2: running   [==================================================&gt;]
verify: Service converged
</pre>



<p>Adesso quindi abbiamo due istanze di WordPress! Come ha fatto questa volta a funzionare? La svolta sta nel fatto che il <strong>binding</strong> della porta è fatto <strong>a livello di servizio</strong> e <strong>non</strong> a livello di <strong>container</strong>! Il servizio quindi rappresenta l’unità non solo “logica”, ma anche fisica, perché è lui responsabile di fare da <strong>punto di accesso e da bilanciatore</strong> alle funzionalità dei container che “proxa”. Vediamo quindi chi “implementa” questi servizi:</p>



<pre>$&gt; docker ps
CONTAINER ID        IMAGE                            COMMAND                  CREATED             STATUS              PORTS                 NAMES
35b70e25a1f3        wordpress:latest                 "docker-entrypoint.s…"   2 minutes ago       Up 2 minutes        80/tcp                wp_wordpress.2.xhpc5jebprigkrhlf742f5272
5aaa08bd0ff9        poc/mysql-for-wordpress:latest   "docker-entrypoint.s…"   22 minutes ago      Up 22 minutes       3306/tcp, 33060/tcp   wp_db.1.uvxb7yhbdu1v36lri90lp2zr8
f0f07649a62e        wordpress:latest                 "docker-entrypoint.s…"   22 minutes ago      Up 22 minutes       80/tcp                wp_wordpress.1.tlobb6t4vnxogbpehwwrr6cyd
</pre>



<p>Con il classico <tt>docker ps</tt> possiamo vedere quali container stanno girando <strong>sul nodo in cui siamo connessi</strong> (occhio a questa cosa!): vediamo infatti che la porta <strong>non viene esposta a livello di container</strong>; possiamo scalarlo tutte le volte che vogliamo: sarà responsabilità del servizio rendere raggiungibili tutti i container <strong>indipendentemente dal nodo in cui sono</strong>.</p>



<p>Quest’ultima considerazione fa sorgere una domanda: in un contesto reale, è necessario riuscire a far arrivare il traffico <em>da fuori fin dentro il cluster Swarm</em>, per cui è molto probabile che ci sarà un bilanciatore davanti. Come si fa quindi a sapere su quale nodo è stato fatto il binding della porta 8000 in modo da poter raggiungere WordPress? La soluzione che adotta Swarm (ma non solo, anche Kubernetes si comporta così) è chiama <strong><a rel="noreferrer noopener" aria-label="Routing Mesh (opens in a new tab)" href="https://docs.docker.com/engine/swarm/ingress/" target="_blank">Routing Mesh</a></strong>: il binding della porta viene fatto su <strong><em>tutti i nodi</em> del cluster</strong>, anche se fisicamente non sta girando un task in quel nodo.</p>



<div class="wp-block-image"><figure class="alignleft is-resized"><amp-img src="../../wp-content/uploads/2019/04/ingress-routing-mesh-1024x456.png" alt="" class="wp-image-17991 amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" width="512" height="227" srcset="https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-1024x456.png 1024w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-300x134.png 300w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-768x342.png 768w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-150x67.png 150w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-706x315.png 706w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh.png 1129w" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg height=&quot;227&quot; width=&quot;512&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;/>"></i-amphtml-sizer><noscript><img src="../../wp-content/uploads/2019/04/ingress-routing-mesh-1024x456.png" alt="" class="wp-image-17991" width="512" height="227" srcset="https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-1024x456.png 1024w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-300x134.png 300w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-768x342.png 768w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-150x67.png 150w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-706x315.png 706w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh.png 1129w" sizes="(max-width: 512px) 100vw, 512px"></noscript></amp-img></figure></div>



<p>Avere chiaro questo semplice concetto credo sia la chiave di volta per pensare quadrimensionalmente e comprendere che ogni operazione che facciamo in Swarm deve tener presente che siamo su un ambiente distribuito.</p>



<h4>Rolling update</h4>



<p>Immaginiamo di dover aggiornare l’immagine del MySQL cambiando il numero di connessioni: abbiamo bisogno di <strong>eseguire nuovamente la build</strong> dell’immagine. </p>



<p>Su questo Swarm non ci può aiutare: abbiamo infatti detto che è un ambiente di runtime, possibilmente multi-nodo: per lavorare bene dovremmo avere un Docker Registry su cui deployare le nostre immagini (magari generate da Jenkins…) così che ogni task potrà scaricarsi l’ultima versione.</p>



<p>Fatta la legge, trovato l’inganno: nel caso di studio che stiamo affrontando, siamo <em>su un solo nodo</em>, quindi possiamo rieseguire la build con Docker Compose e aggiornare il servizio Swarm “db” con la nuova immagine. Ovviamente questo <em>anti pattern</em> è accettabile solo in ambienti di sviluppo, in altre situazioni è meglio evitare!</p>



<p>Dopo aver aggiornato l’immagine (non voglio sapere come 🙂 ), aggiorniamo anche il servizio: questa volta andrà forzato (non si accorge dell’immagine nuova come Compose):</p>



<pre>$&gt; docker service update --force wp_db
wp_db
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</pre>



<p>Controllando i task, ci accorgiamo che <strong>è terminato quello precedente e ne è stato avviato uno nuovo</strong> subito dopo (questo perché l'”<strong>update-order</strong>” è di default a “<strong>stop-first</strong>” – si può verificare con <tt>docker service inspect --pretty wp_db</tt>). A differenza del Compose però, Swarm <strong>non sostituisce</strong> il vecchio container con quello nuovo all’aggiornamento del servizio, ma ne <strong>crea uno nuovo a fianco</strong>, seguendo la policy dell’update-order. Per fare un vero e proprio <em>rolling update senza downtime</em>, è possibile specificare l’order-update a “<strong>start-first</strong>“: in un dato momento ci saranno così contemporaneamente sia il nuovo task che quello vecchio, prima di essere interrotto.</p>



<h3>Tirando le somme</h3>



<p>Ricapitolando quindi, in Swarm c’è un cambio di paradigma da tenere sempre presente per capire quello succede: in fase di deploy <strong>chiediamo</strong> (al nodo master) di <strong>creare un servizio</strong> che provoca la <strong>schedulazione di un task</strong> (per replica), su un nodo disponibile, che <strong>gestisce il ciclo di vita di un container</strong>. Eventuali porte pubblicate dal servizio vengono <strong>registrate su tutti </strong>i nodi in modo da poter essere raggiunte dall’esterno: sarà cura del servizio di bilanciare il traffico sulle istanze dei nodi che eseguono realmente il task richiesto.</p>



<p>Gli attori principali quindi sono i servizi e i task, non i container, che effettivamente diventano <em>effimeri</em>: possono sparire da un nodo e ricomparire in un altro, per cui non possiamo fare affidamento su eventuali modifiche che vengono fatte internamente al di fuori dei volumi montati (che infatti non andrebbero fatte, ma in sviluppo fa comodo). Inoltre, è vero che non riavviare mai lo stesso container, ma crearne uno nuovo a fianco, permette un <strong>rollout senza disservizi</strong> (con Compose non era possibile), ma fa proliferare i vecchi container “parcheggiati” (cioè stoppati) che non verranno più riavviati. Non possiamo quindi fermare un servizio e riavviarlo sperando di ritrovare quelle modifiche fatte nel container precedente, perché, anche se ancora lì, <strong>non verrà riavviato</strong>, ma ne verrà creato uno nuovo.</p>



<p>Inizialmente pensavo fosse “sporcizia” inutile, in realtà, come <a rel="noreferrer noopener" href="https://github.com/docker/swarmkit/issues/1372" target="_blank">dicono anche gli sviluppatori stessi</a>, le vecchie istanze possono essere usate per diagnostica (mi sono ritrovato davvero in produzione ad aver bisogno di riavviarle per vedere i log!) e comunque non superano mai le 5 istanze (configurabili). In ambiente di sviluppo però questo non è di nessuno aiuto, anzi crea solo confusione.</p>



<p>Se alla fine Swarm non vi ha soddisfatto, si può sempre disabilitare con:</p>



<pre>
$&gt; docker swarm leave --force
Node left the swarm.
</pre>



<h2>Conclusioni</h2>



<p>Abbiamo quindi visto una panoramica ad ampio spettro (che non vuole essere esaustiva) delle caratteristiche principali di Compose e di Swarm, nonché di pregi e difetti.</p>



<p>Il passaggio quindi da Compose a Swarm è di sola andata? Lo possiamo considerare un upgrade? A mio avviso no: sono due strumenti in parte diversi che rispondono ad esigenze di tipo diverso. Anche se sembra che facciano la stessa cosa, quello che hanno in comune lo fanno in modo diverso, basti pensare alla gestione dei servizi.</p>



<p>Per quanto mi riguarda, continuerò ad usare <strong>Compose in sviluppo</strong> (e su Jenkins): la gestione dei container è molto semplice e non si ha bisogno di sovrastrutture. Per gli ambienti di <strong>quality</strong> o <strong>produzione</strong> invece è un’altra storia: si può trarre vantaggio dal Compose file scritto in sviluppo, tenendo conto delle <em>differenze degli interpreti di Compose e Swarm</em>: sostanzialmente il Compose è compatibile interamente con la versione 2, mentre Swarm con la 3, anche se qua credo ci sia ancora un gran casino e non è così chiaro. La <a rel="noreferrer noopener" aria-label="matrice di compatibilità (opens in a new tab)" href="https://docs.docker.com/compose/compose-file/" target="_blank">matrice di compatibilità</a> può aiutare a capire.<br><strong>Swarm</strong> credo si comporti bene per <strong>piccoli cluster <em>on premise</em></strong>, dove il numero di nodi non cambia dinamicamente e non ci si attende picchi di traffico anomali. In un contesto B2C, dove il target è il pubblico di internet e la variabilità di traffico è alta, probabilmente conviene spostarsi su soluzioni cloud autoscalabili: a quel punto Swarm non è sufficiente e conviene spostarsi su <a rel="noreferrer noopener" aria-label="Kubernetes (opens in a new tab)" href="https://kubernetes.io/" target="_blank">Kubernetes</a>, di gran lunga più complesso ma più potente.</p>



<p></p>
	</div>

	<footer class="amp-wp-article-footer"><div class="amp-wp-meta amp-wp-tax-category">
		Categories: <a href="../../category/devops/index.html" rel="category tag">Devops</a>, <a href="../../category/docker/index.html" rel="category tag">Docker</a>, <a href="../../category/tutorial-2/index.html" rel="category tag">Tutorial</a>	</div>

	<div class="amp-wp-meta amp-wp-tax-tag">
		Tags: <a href="../../tag/docker/index.html" rel="tag">Docker</a>, <a href="../../tag/docker-compose/index.html" rel="tag">docker compose</a>, <a href="../../tag/docker-swarm/index.html" rel="tag">docker swarm</a>, <a href="../../tag/kubernetes/index.html" rel="tag">kubernetes</a>	</div>
		<div class="amp-wp-meta amp-wp-comments-link">
		<a href="../index.html#respond">
			Leave a Comment		</a>
	</div>
	</footer></article><footer class="amp-wp-footer"><div>
		<h2>CodingJam</h2>
		<a href="#top" class="back-to-top">Back to top</a>
	</div>
</footer></body>
<!-- Mirrored from codingjam.it/da-docker-compose-a-docker-swarm-viaggio-di-sola-andata/amp/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 04 Dec 2020 23:50:37 GMT -->
</html>
