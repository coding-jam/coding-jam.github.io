<!DOCTYPE html>
<html amp lang="en-US" i-amphtml-layout="" i-amphtml-no-boilerplate="" transformed="self;v=1">
<!-- Mirrored from codingjam.it/da-docker-compose-a-docker-swarm-viaggio-di-sola-andata/amp/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 04 Dec 2020 23:50:37 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head><meta charset="utf-8"><style amp-runtime="" i-amphtml-version="012011200012001">html{overflow-x:hidden!important}html.i-amphtml-fie{height:100%!important;width:100%!important}html:not([amp4ads]),html:not([amp4ads]) body{height:auto!important}html:not([amp4ads]) body{margin:0!important}body{-webkit-text-size-adjust:100%;-moz-text-size-adjust:100%;-ms-text-size-adjust:100%;text-size-adjust:100%}html.i-amphtml-singledoc.i-amphtml-embedded{-ms-touch-action:pan-y;touch-action:pan-y}html.i-amphtml-fie>body,html.i-amphtml-singledoc>body{overflow:visible!important}html.i-amphtml-fie:not(.i-amphtml-inabox)>body,html.i-amphtml-singledoc:not(.i-amphtml-inabox)>body{position:relative!important}html.i-amphtml-webview>body{overflow-x:hidden!important;overflow-y:visible!important;min-height:100vh!important}html.i-amphtml-ios-embed-legacy>body{overflow-x:hidden!important;overflow-y:auto!important;position:absolute!important}html.i-amphtml-ios-embed{overflow-y:auto!important;position:static}#i-amphtml-wrapper{overflow-x:hidden!important;overflow-y:auto!important;position:absolute!important;top:0!important;left:0!important;right:0!important;bottom:0!important;margin:0!important;display:block!important}html.i-amphtml-ios-embed.i-amphtml-ios-overscroll,html.i-amphtml-ios-embed.i-amphtml-ios-overscroll>#i-amphtml-wrapper{-webkit-overflow-scrolling:touch!important}#i-amphtml-wrapper>body{position:relative!important;border-top:1px solid transparent!important}#i-amphtml-wrapper+body{visibility:visible}#i-amphtml-wrapper+body .i-amphtml-lightbox-element,#i-amphtml-wrapper+body[i-amphtml-lightbox]{visibility:hidden}#i-amphtml-wrapper+body[i-amphtml-lightbox] .i-amphtml-lightbox-element{visibility:visible}#i-amphtml-wrapper.i-amphtml-scroll-disabled,.i-amphtml-scroll-disabled{overflow-x:hidden!important;overflow-y:hidden!important}amp-instagram{padding:54px 0px 0px!important;background-color:#fff}amp-iframe iframe{box-sizing:border-box!important}[amp-access][amp-access-hide]{display:none}[subscriptions-dialog],body:not(.i-amphtml-subs-ready) [subscriptions-action],body:not(.i-amphtml-subs-ready) [subscriptions-section]{display:none!important}amp-experiment,amp-live-list>[update]{display:none}.i-amphtml-jank-meter{position:fixed;background-color:rgba(232,72,95,0.5);bottom:0;right:0;color:#fff;font-size:16px;z-index:1000;padding:5px}amp-list[resizable-children]>.i-amphtml-loading-container.amp-hidden{display:none!important}amp-list [fetch-error],amp-list[load-more] [load-more-button],amp-list[load-more] [load-more-end],amp-list[load-more] [load-more-failed],amp-list[load-more] [load-more-loading]{display:none}amp-list[diffable] div[role=list]{display:block}amp-story-page,amp-story[standalone]{min-height:1px!important;display:block!important;height:100%!important;margin:0!important;padding:0!important;overflow:hidden!important;width:100%!important}amp-story[standalone]{background-color:#202125!important;position:relative!important}amp-story-page{background-color:#757575}amp-story .amp-active>div,amp-story .i-amphtml-loader-background{display:none!important}amp-story-page:not(:first-of-type):not([distance]):not([active]){transform:translateY(1000vh)!important}amp-autocomplete{position:relative!important;display:inline-block!important}amp-autocomplete>input,amp-autocomplete>textarea{padding:0.5rem;border:1px solid rgba(0,0,0,0.33)}.i-amphtml-autocomplete-results,amp-autocomplete>input,amp-autocomplete>textarea{font-size:1rem;line-height:1.5rem}[amp-fx^=fly-in]{visibility:hidden}amp-script[nodom]{position:fixed!important;top:0!important;width:1px!important;height:1px!important;overflow:hidden!important;visibility:hidden}
/*# sourceURL=/css/ampdoc.css*/[hidden]{display:none!important}.i-amphtml-element{display:inline-block}.i-amphtml-blurry-placeholder{transition:opacity 0.3s cubic-bezier(0.0,0.0,0.2,1)!important;pointer-events:none}[layout=nodisplay]:not(.i-amphtml-element){display:none!important}.i-amphtml-layout-fixed,[layout=fixed][width][height]:not(.i-amphtml-layout-fixed){display:inline-block;position:relative}.i-amphtml-layout-responsive,[layout=responsive][width][height]:not(.i-amphtml-layout-responsive),[width][height][heights]:not([layout]):not(.i-amphtml-layout-responsive),[width][height][sizes]:not([layout]):not(.i-amphtml-layout-responsive){display:block;position:relative}.i-amphtml-layout-intrinsic,[layout=intrinsic][width][height]:not(.i-amphtml-layout-intrinsic){display:inline-block;position:relative;max-width:100%}.i-amphtml-layout-intrinsic .i-amphtml-sizer{max-width:100%}.i-amphtml-intrinsic-sizer{max-width:100%;display:block!important}.i-amphtml-layout-container,.i-amphtml-layout-fixed-height,[layout=container],[layout=fixed-height][height]:not(.i-amphtml-layout-fixed-height){display:block;position:relative}.i-amphtml-layout-fill,.i-amphtml-layout-fill.i-amphtml-notbuilt,[layout=fill]:not(.i-amphtml-layout-fill){display:block;overflow:hidden!important;position:absolute;top:0;left:0;bottom:0;right:0}.i-amphtml-layout-flex-item,[layout=flex-item]:not(.i-amphtml-layout-flex-item){display:block;position:relative;-ms-flex:1 1 auto;flex:1 1 auto}.i-amphtml-layout-fluid{position:relative}.i-amphtml-layout-size-defined{overflow:hidden!important}.i-amphtml-layout-awaiting-size{position:absolute!important;top:auto!important;bottom:auto!important}i-amphtml-sizer{display:block!important}@supports (aspect-ratio:1/1){i-amphtml-sizer.i-amphtml-disable-for-ar{display:none!important}}.i-amphtml-blurry-placeholder,.i-amphtml-fill-content{display:block;height:0;max-height:100%;max-width:100%;min-height:100%;min-width:100%;width:0;margin:auto}.i-amphtml-layout-size-defined .i-amphtml-fill-content{position:absolute;top:0;left:0;bottom:0;right:0}.i-amphtml-replaced-content,.i-amphtml-screen-reader{padding:0!important;border:none!important}.i-amphtml-screen-reader{position:fixed!important;top:0px!important;left:0px!important;width:4px!important;height:4px!important;opacity:0!important;overflow:hidden!important;margin:0!important;display:block!important;visibility:visible!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:8px!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:12px!important}.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader~.i-amphtml-screen-reader{left:16px!important}.i-amphtml-unresolved{position:relative;overflow:hidden!important}.i-amphtml-select-disabled{-webkit-user-select:none!important;-ms-user-select:none!important;user-select:none!important}.i-amphtml-notbuilt,[layout]:not(.i-amphtml-element),[width][height][heights]:not([layout]):not(.i-amphtml-element),[width][height][sizes]:not([layout]):not(.i-amphtml-element){position:relative;overflow:hidden!important;color:transparent!important}.i-amphtml-notbuilt:not(.i-amphtml-layout-container)>*,[layout]:not([layout=container]):not(.i-amphtml-element)>*,[width][height][heights]:not([layout]):not(.i-amphtml-element)>*,[width][height][sizes]:not([layout]):not(.i-amphtml-element)>*{display:none}amp-img:not(.i-amphtml-element)[i-amphtml-ssr]>img.i-amphtml-fill-content{display:block}.i-amphtml-notbuilt:not(.i-amphtml-layout-container),[layout]:not([layout=container]):not(.i-amphtml-element),[width][height][heights]:not([layout]):not(.i-amphtml-element),[width][height][sizes]:not([layout]):not(.i-amphtml-element){color:transparent!important;line-height:0!important}.i-amphtml-ghost{visibility:hidden!important}.i-amphtml-element>[placeholder],[layout]:not(.i-amphtml-element)>[placeholder],[width][height][heights]:not([layout]):not(.i-amphtml-element)>[placeholder],[width][height][sizes]:not([layout]):not(.i-amphtml-element)>[placeholder]{display:block}.i-amphtml-element>[placeholder].amp-hidden,.i-amphtml-element>[placeholder].hidden{visibility:hidden}.i-amphtml-element:not(.amp-notsupported)>[fallback],.i-amphtml-layout-container>[placeholder].amp-hidden,.i-amphtml-layout-container>[placeholder].hidden{display:none}.i-amphtml-layout-size-defined>[fallback],.i-amphtml-layout-size-defined>[placeholder]{position:absolute!important;top:0!important;left:0!important;right:0!important;bottom:0!important;z-index:1}.i-amphtml-notbuilt>[placeholder]{display:block!important}.i-amphtml-hidden-by-media-query{display:none!important}.i-amphtml-element-error{background:red!important;color:#fff!important;position:relative!important}.i-amphtml-element-error:before{content:attr(error-message)}i-amp-scroll-container,i-amphtml-scroll-container{position:absolute;top:0;left:0;right:0;bottom:0;display:block}i-amp-scroll-container.amp-active,i-amphtml-scroll-container.amp-active{overflow:auto;-webkit-overflow-scrolling:touch}.i-amphtml-loading-container{display:block!important;pointer-events:none;z-index:1}.i-amphtml-notbuilt>.i-amphtml-loading-container{display:block!important}.i-amphtml-loading-container.amp-hidden{visibility:hidden}.i-amphtml-element>[overflow]{cursor:pointer;position:relative;z-index:2;visibility:hidden;display:initial;line-height:normal}.i-amphtml-element>[overflow].amp-visible{visibility:visible}template{display:none!important}.amp-border-box,.amp-border-box *,.amp-border-box :after,.amp-border-box :before{box-sizing:border-box}amp-pixel{display:none!important}amp-analytics,amp-auto-ads,amp-story-auto-ads{position:fixed!important;top:0!important;width:1px!important;height:1px!important;overflow:hidden!important;visibility:hidden}html.i-amphtml-fie>amp-analytics{position:initial!important}[visible-when-invalid]:not(.visible),form [submit-error],form [submit-success],form [submitting]{display:none}amp-accordion{display:block!important}amp-accordion>section{float:none!important}amp-accordion>section>*{float:none!important;display:block!important;overflow:hidden!important;position:relative!important}amp-accordion,amp-accordion>section{margin:0}amp-accordion:not(.i-amphtml-built)>section>:last-child{display:none!important}amp-accordion:not(.i-amphtml-built)>section[expanded]>:last-child{display:block!important}
/*# sourceURL=/css/ampshared.css*/</style><meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1"><meta name="generator" content="AMP Plugin v1.5.3; mode=reader"><meta name="generator" content="WordPress 5.4.1"><title>Da Docker Compose a Docker Swarm: viaggio di sola andata? ‚Äì CodingJam</title><link rel="preconnect" href="https://cdn.ampproject.org/"><link rel="preload" as="script" href="https://cdn.ampproject.org/v0.js"><script async="" src="https://cdn.ampproject.org/v0.js"></script><style amp-custom="">.wp-block-image{margin-bottom:1em}.wp-block-image amp-img{max-width:100%}.wp-block-image .alignleft,.wp-block-image.is-resized{display:table}.wp-block-image .alignleft{float:left;margin:.5em 1em .5em 0}.wp-block-quote{border-left:4px solid #000;margin:0 0 28px;padding-left:1em}.wp-block-quote footer{color:#6c7781;font-size:13px;margin-top:1em;position:relative;font-style:normal}.alignleft{margin-top:1em;margin-right:auto;margin-bottom:1em;margin-left:auto}.alignleft{float:left}.amp-wp-enforced-sizes{max-width:100%;margin:0 auto}amp-img.amp-wp-enforced-sizes[layout="intrinsic"] > img{object-fit:contain}html{background:#0a89c0}body{background:#fff;color:#353535;font-family:Georgia,"Times New Roman",Times,Serif;font-weight:300;line-height:1.75em}p,ul,figure{margin:0 0 1em;padding:0}a,a:visited{color:#0a89c0}a:hover,a:active,a:focus{color:#353535}blockquote{color:#353535;background:rgba(127,127,127,.125);border-left:2px solid #0a89c0;margin:8px 0 24px 0;padding:16px}blockquote p:last-child{margin-bottom:0}.amp-wp-meta,.amp-wp-header div,.amp-wp-title,.amp-wp-tax-category,.amp-wp-tax-tag,.amp-wp-comments-link,.amp-wp-footer p,.back-to-top{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Roboto","Oxygen-Sans","Ubuntu","Cantarell","Helvetica Neue",sans-serif}.amp-wp-header{background-color:#0a89c0}.amp-wp-header div{color:#fff;font-size:1em;font-weight:400;margin:0 auto;max-width:calc(840px - 32px);padding:.875em 16px;position:relative}.amp-wp-header a{color:#fff;text-decoration:none}.amp-wp-header .amp-wp-site-icon{background-color:#fff;border:1px solid #fff;border-radius:50%;position:absolute;right:18px;top:10px}.amp-wp-article{color:#353535;font-weight:400;margin:1.5em auto;max-width:840px;overflow-wrap:break-word;word-wrap:break-word}.amp-wp-article-header{align-items:center;align-content:stretch;display:flex;flex-wrap:wrap;justify-content:space-between;margin:1.5em 16px 0}.amp-wp-title{color:#353535;display:block;flex:1 0 100%;font-weight:900;margin:0 0 .625em;width:100%}.amp-wp-meta{color:#696969;display:inline-block;flex:2 1 50%;font-size:.875em;line-height:1.5em;margin:0 0 1.5em;padding:0}.amp-wp-article-header .amp-wp-meta:last-of-type{text-align:right}.amp-wp-article-header .amp-wp-meta:first-of-type{text-align:left}.amp-wp-byline amp-img,.amp-wp-byline .amp-wp-author{display:inline-block;vertical-align:middle}.amp-wp-byline amp-img{border:1px solid #0a89c0;border-radius:50%;position:relative;margin-right:6px}.amp-wp-posted-on{text-align:right}.amp-wp-article-content{margin:0 16px}.amp-wp-article-content ul{margin-left:1em}.amp-wp-article-content amp-img{margin:0 auto}.amp-wp-article-content amp-img.alignleft{margin:0 16px 1em 0}.amp-wp-article-footer .amp-wp-meta{display:block}.amp-wp-tax-category,.amp-wp-tax-tag{color:#696969;font-size:.875em;line-height:1.5em;margin:1.5em 16px}.amp-wp-comments-link{color:#696969;font-size:.875em;line-height:1.5em;text-align:center;margin:2.25em 0 1.5em}.amp-wp-comments-link a{border-style:solid;border-color:#c2c2c2;border-width:1px 1px 2px;border-radius:4px;background-color:transparent;color:#0a89c0;cursor:pointer;display:block;font-size:14px;font-weight:600;line-height:18px;margin:0 auto;max-width:200px;padding:11px 16px;text-decoration:none;width:50%;-webkit-transition:background-color .2s ease;transition:background-color .2s ease}.amp-wp-footer{border-top:1px solid #c2c2c2;margin:calc(1.5em - 1px) 0 0}.amp-wp-footer div{margin:0 auto;max-width:calc(840px - 32px);padding:1.25em 16px 1.25em;position:relative}.amp-wp-footer h2{font-size:1em;line-height:1.375em;margin:0 0 .5em}.amp-wp-footer p{color:#696969;font-size:.8em;line-height:1.5em;margin:0 85px 0 0}.amp-wp-footer a{text-decoration:none}.back-to-top{bottom:1.275em;font-size:.8em;font-weight:600;line-height:2em;position:absolute;right:16px}:root:not(#_):not(#_):not(#_):not(#_):not(#_) .amp-wp-276eb22{font-size:18px}

/*# sourceURL=amp-custom.css */</style><link rel="canonical" href="../index.html"><script type="application/ld+json">{"@context":"http:\/\/schema.org","publisher":{"@type":"Organization","name":"CodingJam","logo":"https:\/\/codingjam.it\/wp-content\/uploads\/2018\/09\/cropped-logo-cnj-bianco.png"},"@type":"BlogPosting","mainEntityOfPage":"https:\/\/codingjam.it\/da-docker-compose-a-docker-swarm-viaggio-di-sola-andata\/","headline":"Da Docker Compose a Docker Swarm: viaggio di sola andata?","datePublished":"2019-05-06T08:02:05+02:00","dateModified":"2019-04-22T15:13:00+02:00","author":{"@type":"Person","name":"Andrea Como"},"image":"https:\/\/codingjam.it\/wp-content\/uploads\/2019\/04\/ingress-routing-mesh.png"}</script></head><body class="">

<header id="top" class="amp-wp-header"><div>
		<a href="../../index.html">
										<amp-img src="../../wp-content/uploads/2018/09/cropped-codingjam-jar-transp-white-big-512-32x32.png" width="32" height="32" class="amp-wp-site-icon i-amphtml-layout-fixed i-amphtml-layout-size-defined" style="width:32px;height:32px;" i-amphtml-layout="fixed"></amp-img><span class="amp-site-title">
				CodingJam			</span>
		</a>

					</div>
</header><article class="amp-wp-article"><header class="amp-wp-article-header"><h1 class="amp-wp-title">Da Docker Compose a Docker Swarm: viaggio di sola andata?</h1>
			<div class="amp-wp-meta amp-wp-byline">
					<amp-img src="https://secure.gravatar.com/avatar/684ede46c9386ff5430335a42fd5b011?s=24&amp;d=mm&amp;r=g" alt="Andrea Como" width="24" height="24" layout="fixed" class="i-amphtml-layout-fixed i-amphtml-layout-size-defined" style="width:24px;height:24px;" i-amphtml-layout="fixed"></amp-img><span class="amp-wp-author author vcard">Andrea Como</span>
	</div>
<div class="amp-wp-meta amp-wp-posted-on">
	<time datetime="2019-05-06T10:02:05+00:00">
		2 years ago	</time></div>
	</header><div class="amp-wp-article-content">
		
<p>Sin dalle prime ore di uso di Docker, si sente subito la necessit√† di <em>salvare in qualche formato</em>, che non sia uno script bash, i mille parametri che si possono passare al comando <tt>docker run</tt>. Ben presto si fa la conoscenza di <strong><a href="https://docs.docker.com/compose/" target="_blank">Docker Compose</a></strong>: avere un file YAML che descrive i parametri di lancio, ma non solo, di uno o pi√π container ci fa sentire al sicuro perch√© possiamo metterlo sotto controllo di versione. Appena per√≤ abbiamo bisogno di far girare i container su pi√π macchine, ci rendiamo conto che nemmeno questo √® lo strumento che stavamo cercando. Abbiamo bisogno di <strong><a href="https://docs.docker.com/engine/swarm/" target="_blank">Docker Swarm</a></strong> per fare questo e, da tre anni ormai dalla sua nascita, possiamo considerarlo ormai <em>production-ready</em>.</p>



<p>Se siete qua, probabilmente sapete gi√† cosa sono Compose e Swarm e magari vi state chiedendo se conviene fare un ‚Äúupgrade‚Äù. Cerchiamo insieme di capire se si tratta davvero di un upgrade e cosa comporta.</p>



<h2>Docker Compose</h2>



<blockquote class="wp-block-quote amp-wp-276eb22" data-amp-original-style="font-size: 18px"><p>Compose √® uno strumento per definire ed eseguire applicazioni Docker multi-container. Con Compose, √® possibile definire un file YAML per configurare i servizi applicativi.</p></blockquote>



<p>Nel file YAML infatti, √® possibile definire pi√π container Docker sotto il cappello ‚Äú<em>services</em>‚Äú, sia <strong>a partire da </strong><tt><strong>Dockerfile</strong></tt> che da <strong>immagini gi√† pronte</strong>.</p>



<h3>Docker Compose all‚Äôopera</h3>



<p>Immaginiamo di voler tirare su WordPress, che ha bisogno di MySQL. All‚Äôinterno di una cartella chiamata <tt>wordpress-docker</tt>, creiamo un file di nome <tt>docker-compose.yml</tt> con questo contenuto (presente su <a href="https://github.com/coding-jam/wordpress-docker-poc" target="_blank" rel="noreferrer noopener" aria-label="GitHub (opens in a new tab)">GitHub</a>):</p>



<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">version: '3.7'

services:
   db:
     build: ./mysql
     image: poc/mysql-for-wordpress
     volumes:
       - db_data:/var/lib/mysql
     restart: always
     environment:
       MYSQL_ROOT_PASSWORD: somewordpress
       MYSQL_DATABASE: wordpress
       MYSQL_USER: wordpress
       MYSQL_PASSWORD: wordpress

   wordpress:
     depends_on:
       - db
     image: wordpress:latest
     ports:
       - "8000:80"
     restart: always
     environment:
       WORDPRESS_DB_HOST: db:3306
       WORDPRESS_DB_USER: wordpress
       WORDPRESS_DB_PASSWORD: wordpress
       WORDPRESS_DB_NAME: wordpress
volumes:
    db_data: {}</pre>



<p>In questo caso abbiamo fatto una personalizzazione (non che ce ne fosse bisogno, √® solo a scopo didattico), tramite <tt>Dockerfile</tt>, del container di MySQL, mentre abbiamo preso quello di default per WordPress. Da notare il valore di <tt>WORDPRESS_DB_HOST</tt> ‚Äú<tt>db:3306</tt>‚Äú: il riferimento al container del database viene risolto con il <strong>nome del servizio associato</strong>.</p>



<p>Docker Compose per√≤ <em>non √® nativamente disponibile</em> quando si installa Docker, ma √® un tool separato, scritto in Python, che <a rel="noreferrer noopener" aria-label="va installato autonomamente (opens in a new tab)" href="https://docs.docker.com/compose/install/" target="_blank">va installato autonomamente</a> e <strong>automatizza certe operazioni</strong> del demone Docker. Ha una propria CLI, accessibile tramite il comando <tt>docker-compose</tt>, che semplifica notevolmente la ‚Äúgestione di gruppo‚Äù dei servizi elencati nel file YAML.</p>



<p>Per avviare tutti i servizi, basta eseguire:</p>



<pre>$&gt; docker-compose up -d
</pre>



<p>Dove con <tt>-d</tt> si evita di rimanere attaccati al <em>system out</em> dei container avviati. Cosa accade adesso? Il controllo della console ci viene restituito <strong>solo dopo</strong> queste operazioni:</p>



<pre>Creating network "wordpress-docker_default" with the default driver
Creating volume "wordpress-docker_db_data" with default driver
Building db
Step 1/2 : FROM mysql:5.7
 ---&gt; 98455b9624a9
Step 2/2 : COPY *.cnf /etc/mysql/conf.d/
 ---&gt; 52440b13db7c

Successfully built 52440b13db7c
Successfully tagged poc/mysql-for-wordpress:latest
WARNING: Image for service db was built because it did not already exist. To rebuild this image you must use `docker-compose build` or `docker-compose up --build`.
Creating wordpress-docker_db_1 ... done
Creating wordpress-docker_wordpress_1 ... done
</pre>



<ul><li>viene creato un network che <strong>lega i due container</strong> e <strong>li isola da tutto il resto</strong>. Il nome √® curioso: si tratta del nome della cartella dove risiede il <tt>docker-compose.yml</tt> (chiamata <tt>wordpress-docker</tt> ricordate?) a cui viene apposto ‚Äúdefault‚Äù.</li><li>viene creato il volume ‚Äúdb_data‚Äù, sempre con prefisso <tt>wordpress-docker</tt>.</li><li>viene creata l‚Äô<strong>immagine modificata del database</strong>, chiamata <tt>poc/mysql-for-wordpress</tt>, tramite il <tt>Dockerfile</tt> presente nella cartella <tt>mysql</tt>.</li><li>vengono <strong>avviati i container</strong> dei servizi ‚Äúdb‚Äù e ‚Äúwordpress‚Äù, esattamente in quest‚Äôordine, per via delle dipendenze. In questo caso, oltre al consueto prefisso <tt>wordpress-docker</tt>, notiamo un numero dopo che segue il nome del servizio: si tratta della prima istanza del servizio.</li></ul><p>La prima cosa che salta all‚Äôocchio √® che il <strong>nome della cartella</strong> che contiene il file YAML viene usata come ‚Äú<em><strong>namespace</strong></em>‚Äù per la nomenclatura delle risorse create: questo approccio √® interessante perch√© permette di rilanciare lo stesso stack di servizi da cartelle diverse senza creare conflitti.</p>



<p>Tutte queste operazioni sono <strong>sincrone</strong> con la CLI: finch√© i container non saranno avviati, non potremo riprendere il controllo della console. La CLI di compose √® interessante perch√© permette di controllare in gruppo i container:</p>



<pre>$&gt; docker-compose ps

            Name                          Command               State          Ports
--------------------------------------------------------------------------------------------
wordpress-docker_db_1          docker-entrypoint.sh mysqld      Up      3306/tcp, 33060/tcp
wordpress-docker_wordpress_1   docker-entrypoint.sh apach ...   Up      0.0.0.0:8000-&gt;80/tcp
</pre>



<p>visualizza lo <strong>stato dei container</strong> e le <strong>relative porte mappate</strong> (se ci sono). E‚Äô possibile anche controllarne uno solo, chiamato con il nome del servizio:</p>



<pre>$&gt; docker-compose stop wordpress
Stopping wordpress-docker_wordpress_1 ... done

$&gt; docker-compose start wordpress
Starting wordpress ... done
</pre>



<p>Se si riesegue il comando di avvio di tutti i servizi (<tt>up</tt>), Compose controller√† per noi <strong>se esistono versioni nuove delle immagini</strong> ed eventualmente le <strong>avvier√†</strong>¬†(con le dipendenze in cascata). Modificando l‚Äôimmagine del database quindi, verr√† riavviato anche WordPress:</p>



<pre>$&gt; docker-compose up -d
Recreating wordpress-docker_db_1 ... done
Recreating wordpress-docker_wordpress_1 ... done
</pre>



<h3>Tirando le somme</h3>



<p>Fin qua abbiamo visto che Compose √® perfetto per gestire il ciclo di <strong>build</strong> e di <strong>runtime</strong> di pi√π servizi insieme, perch√© dovremmo avere bisogno di altro? </p>



<p>Per il supporto allo sviluppo software √® perfetto: possiamo praticamente creare e tirare su l‚Äôinfrastruttura di cui abbiamo bisogno sulla nostra macchina di sviluppo! A mio avviso, Compose comincia a stare stretto in due casi:</p>



<ul><li>quando si ha bisogno che i servizi <strong>girino su pi√π macchine</strong>, Compose <strong>non</strong> √® in grado di controllare questa situazione. La rete che viene creata tra i servizi istanziati √® una sottorete dello <strong>stesso host,</strong> puro isolamento basato su <tt>iptables</tt>: non esiste un concetto di ‚Äúcluster di nodi‚Äù. Non possiamo quindi far girare WordPress su una macchina e il MySQL in un‚Äôaltra gestiti da Compose, perch√© non si ‚Äúvedrebbero‚Äù a livello di rete: i Compose delle due macchine non avrebbero niente in comune. L‚Äôunico modo per farli comunicare sarebbe esporre le porte sui rispettivi host e far dialogare i servizi tramite gli hostname, ma si perde tutta la dinamicit√† offerta da Docker.</li><li>se si prova a <strong>scalare un servizio</strong> (ovviamente sullo stesso host perch√© non si pu√≤ fare altrimenti) che ha il <em>binding</em> di una porta sull‚Äôhost, lo <strong>scaling verr√† impedito</strong> perch√© la porta √® gi√† occupata dalla prima istanza! Proviamo infatti a scalare WordPress: 

<pre>$&gt; docker-compose up -d --scale wordpress=2  
WARNING: The "wordpress" service specifies a port on the host. If multiple containers for this service are created on a single host, the port will clash.  
Starting wordpress-docker_wordpress_1 ... done  
Creating wordpress-docker_wordpress_2 ... error  
ERROR: for wordpress-docker_wordpress_2  Cannot start service wordpress: driver failed programming external connectivity on endpoint wordpress-docker_wordpress_2 (f19636f06cfcf461c0d175a182fa3b7f53bf0f9c430260e76320f7bfa31f9220): Bind for 0.0.0.0:8000 failed: port is already allocated </pre>

Volendo scalare il database, invece, questo funzionerebbe perch√© non ha binding: 

<pre>$&gt; docker-compose up -d --scale db=2 
Starting wordpress-docker_db_1 ... done 
Creating wordpress-docker_db_2 ... done 
wordpress-docker_wordpress_1 is up-to-date 
</pre> 

Anche se poi il risultato √® che 2 istanze di MySQL sullo stesso volume possono solo fare danni :), quindi meglio evitare! </li></ul><p>Quando si ha la necessit√† di controllare pi√π servizi su pi√π macchine, e magari scalarli su di esse, √® necessario qualcosa di pi√π, √® necessario almeno <strong>Docker Swarm</strong>. Prima di continuare, distruggiamo tutti i container, compresi i volumi:</p>



<pre>$&gt; docker-compose down -v
Stopping wordpress-docker_wordpress_1 ... done
Stopping wordpress-docker_db_1        ... done
Removing wordpress-docker_wordpress_1 ... done
Removing wordpress-docker_db_1        ... done
Removing network wordpress-docker_default
Removing volume wordpress-docker_db_data
</pre>



<h2>Docker Swarm</h2>



<blockquote class="wp-block-quote amp-wp-276eb22" data-amp-original-style="font-size: 18px"><p>Uno swarm (‚Äúsciame‚Äù in italiano) consiste in un <strong>insieme di <strong>nodi</strong> Docker</strong> che si comportano da <em>manager,¬†</em>per la gestione del cluster stesso, e <em>worker</em>, che eseguono <strong>servizi</strong>.</p></blockquote>



<p>Swarm si propone quindi come lo strumento di default per la <em>gestione di container in un cluster di nodi Docker</em>.  </p>



<h3>Un po‚Äô di teoria</h3>



<p>Gi√† dalla definizione, emergono una serie di <a rel="noreferrer noopener" aria-label="concetti e terminologie (opens in a new tab)" href="https://docs.docker.com/engine/swarm/key-concepts" target="_blank">concetti e terminologie</a> che √® bene avere chiari prima di andare avanti:</p>



<ul><li><strong><em>nodi</em></strong>: si tratta di <strong>istanze di Docker</strong> che partecipano al cluster. Solitamente, ogni istanza del motore di Docker risiede su <em>una</em> macchina fisica o virtuale che sia: di conseguenza si pu√≤ pensare (ma non √® obbligatorio) ad un nodo dello swarm come ad una macchina. I nodi possono essere di tipo <strong><em>manager</em></strong> o <strong><em>worker</em>¬†</strong>(o¬†<strong>entrambi</strong>): pi√π nodi possono avere il ruolo di master, ma solo uno √® eletto in un certo momento a coordinare i servizi e a mantenere lo stato del cluster. Il <strong>deploy</strong> di una applicazione <strong>passa sempre da un nodo master</strong> che <strong>delega un </strong><em><strong>task</strong></em><strong> ad un nodo worker</strong> (o un altro master, o a se stesso) in modo che <em>esegua il servizio richiesto</em>. I nodi del cluster informano sempre il nodo master sullo stato dei task assegnati, in modo da mantenere sempre lo stato dei servizi come richiesto.</li><li><strong><em>task</em></strong> e <strong><em>servizi</em></strong>: abbiamo visto che un nodo master assegna il compito (<em>task</em> appunto) di eseguire un certo <em>servizio</em> su un nodo del cluster (possibilmente worker), ovvero avviare una o pi√π istanze di un container a partire da una immagine. Questo concetto gi√† ci suona pi√π familiare: servizi e container li avevamo visti anche con Compose. Ma questo task invece? Come vedremo a breve, √® un concetto abbastanza trasparente, ma fondamentale, nell‚Äôuso di Swarm, se non per il fatto che tutta l‚Äôinterazione tra il nodo master e la CLI √® <strong>asincrona</strong>: da qua si evince che c‚Äô√® qualcuno che sta facendo qualcosa (task) dopo che abbiamo eseguito un comando.</li></ul><h3>Docker Swarm all‚Äôopera</h3>



<p>Swarm <em>non √® attivo di default</em>, anche se <strong>√® gi√† disponibile</strong> nell‚Äôinstallazione di Docker (a differenza del Compose). Dobbiamo quindi solo decidere come attivarlo: per lo <em>sviluppo</em>, cio√® sulla <em>nostra macchina</em>, possiamo fare un <strong>cluster di un nodo</strong> semplicemente digitando:</p>



<pre>$&gt; docker swarm init
Swarm initialized: current node (keiak51s53xowk57oq24bd5yi) is now a manager.
</pre>



<p>Docker entra in <strong>modalit√† Swarm</strong> e considera se stesso un <strong>nodo master</strong>. L‚Äôoutput completo del comando (qua omesso) d√† anche istruzioni su come <a rel="noreferrer noopener" aria-label="aggiungere altri nodi (opens in a new tab)" href="https://docs.docker.com/engine/reference/commandline/swarm_join/" target="_blank">aggiungere altri nodi</a> al cluster (sia master che worker). Tramite i comandi della CLI <tt>docker swarm</tt> e <tt>docker node</tt> √® possibile gestire il cluster.</p>



<p>Ma torniamo a ci√≤ che ci interessa: pu√≤ Swarm aiutarci a superare i limiti che abbiamo visto con Compose? Essendo al momento su un singolo nodo, non noteremo grandi differenze, se non per il fatto che <strong>adesso lo scaling funzioner√†</strong>!! Ma andiamo per gradi.</p>



<h4>Docker stacks</h4>



<p>Nel gergo Swarm, l‚Äôinsieme dei servizi che possiamo deployare si chiama ‚Äú<strong>stack</strong>‚Äú, cio√® pila di servizi. La cosa scaltra di Swarm √® che <strong>usa i file YAML di Compose</strong>, quindi il <em>passaggio a Swarm √® molto semplice</em> (anzi, si √® quasi invogliati): basta riusare lo <strong>stesso identico file di prima</strong> e deployare lo stack cos√¨:</p>



<pre>$&gt; docker stack deploy -c docker-compose.yml wp
Ignoring unsupported options: build, restart

Creating network wp_default
Creating service wp_db
Creating service wp_wordpress
</pre>



<p>Senza sapere n√© leggere n√© scrivere notiamo che:</p>



<ul><li>Il comando <tt>stack deploy</tt> vuole per forza il riferimento al file YAML e il <strong>nome dello stack</strong> da creare. Il nome √® usato come <em>prefisso</em> per le risorse create: il servizio WordPress, il database e la network che li isola. Fossimo un un cluster con pi√π nodi, questa network <strong>sarebbe accessibile anche cross-nodo</strong> se i due container fossero su nodi diversi.</li><li>Le direttive <tt>build</tt> e <tt>restart</tt> sono state ignorate! Questo significa che <strong>non posso eseguire le build</strong> delle immagini con Swarm?! Ebbene √® proprio cos√¨! Come direbbe Doc: ‚Äú<em>Marty, non stai pensando quadrimensionalmente!</em>‚Äù Che senso avrebbe creare immagini su un nodo se poi non √® detto che vengano eseguite li? Come portarle sugli altri nodi? Il problema non si pone: <strong>Swarm √® un ambiente di runtime</strong>: qualcun altro deve essere responsabile di fornirgli le immagini gi√† pronte. E <tt>restart</tt> invece perch√© viene ignorato? A dirla tutta, Swarm e Compose usano dialetti leggermente diversi del descrittore YAML (in base alla versione): questo discorso lo accenniamo pi√π avanti.</li></ul><p>La CLI ha restituito subito il controllo, significa che <em>qualcuno sta facendo qualcosa</em> (ricordate i task?) in <em>background</em> (magari su un altra macchina nel caso multi-nodo). L‚Äôinterazione √® quindi <strong>asincrona</strong>: come si fa a vedere cosa sta succedendo? Il comando </p>



<pre class="wp-block-preformatted">$&gt; docker stack ps wp <br>ID                  NAME                IMAGE                            NODE                    DESIRED STATE       CURRENT STATE            ERROR               PORTS <br>tlobb6t4vnxo        wp_wordpress.1      wordpress:latest                 linuxkit-025000000001   Running             Running 2 minutes ago <br>uvxb7yhbdu1v        wp_db.1             poc/mysql-for-wordpress:latest   linuxkit-025000000001   Running             Running 2 minutes ago</pre>



<p>ci d√† una panoramica dello <strong>stato dei task</strong> di <tt>wp</tt>: abbiamo quindi un task per ogni istanza (per questo il numerino in fondo al nome) di container che implementa il servizio richiesto. Chi li ha istruiti a comportarsi cos√¨? Per capire, dobbiamo approfondire il concetto di <strong>servizio</strong>.</p>



<h4>Docker services</h4>



<p>In Compose si parla di servizi: ci appaiono come dei <em>proxy sul container</em> (o le sue repliche) gestite dal Compose. In Swarm questo concetto √® reso pi√π forte ed assume un ruolo centrale, diventando di fatto l‚Äô<strong><em>unit√† di deployment</em></strong>.</p>



<div class="wp-block-image"><figure class="alignleft is-resized"><amp-img src="../../wp-content/uploads/2019/04/services-diagram.png" alt="services-diagram" class="wp-image-17978 amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" width="396" height="272" srcset="https://codingjam.it/wp-content/uploads/2019/04/services-diagram.png 800w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-300x207.png 300w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-768x530.png 768w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-150x104.png 150w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-683x471.png 683w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-706x487.png 706w" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg height=&quot;272&quot; width=&quot;396&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;/>"></i-amphtml-sizer><noscript><img src="../../wp-content/uploads/2019/04/services-diagram.png" alt="services-diagram" class="wp-image-17978" width="396" height="272" srcset="https://codingjam.it/wp-content/uploads/2019/04/services-diagram.png 800w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-300x207.png 300w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-768x530.png 768w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-150x104.png 150w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-683x471.png 683w, https://codingjam.it/wp-content/uploads/2019/04/services-diagram-706x487.png 706w" sizes="(max-width: 396px) 100vw, 396px"></noscript></amp-img></figure></div>



<p>Quando infatti si <strong>deploya una applicazione, in realt√† si chiede (al master) di creare un servizio</strong>, il cui <strong>stato desiderato</strong> (immagine da usare, porte esposte, overlay di rete‚Ä¶) √® definito nel file YAML. Dalla richiesta di servizio si <strong>generano</strong> (in gergo si ‚Äúschedulano‚Äù) quindi i task che istanziano i container nel cluster, in modo da ‚Äúimplementare‚Äù lo stato desiderato. Vediamo allora i servizi generati dal nostro stack <tt>wp</tt>:</p>



<pre>$ docker stack services wp
ID                  NAME                MODE                REPLICAS            IMAGE                            PORTS
bo6cdv2jwnqz        wp_db               replicated          1/1                 poc/mysql-for-wordpress:latest
klsaic86xu39        wp_wordpress        replicated          1/1                 wordpress:latest                 *:8000-&gt;80/tcp
</pre>



<p>Notiamo che abbiamo <em>una replica</em> rispettivamente del database e di WordPress (corrispondenti ai task), nonch√© il <em>binding</em> della porta 80 di quest‚Äôultimo sulla 8000 dell‚Äôhost. Adesso siamo in condizioni di<strong> poter scalare il container di WordPress</strong> a due repliche (anche perch√© √® l‚Äôunico che ha senso) senza avere problemi:</p>



<pre>$&gt; docker service scale wp_wordpress=2
wp_wordpress scaled to 2
overall progress: 2 out of 2 tasks
1/2: running   [==================================================&gt;]
2/2: running   [==================================================&gt;]
verify: Service converged
</pre>



<p>Adesso quindi abbiamo due istanze di WordPress! Come ha fatto questa volta a funzionare? La svolta sta nel fatto che il <strong>binding</strong> della porta √® fatto <strong>a livello di servizio</strong> e <strong>non</strong> a livello di <strong>container</strong>! Il servizio quindi rappresenta l‚Äôunit√† non solo ‚Äúlogica‚Äù, ma anche fisica, perch√© √® lui responsabile di fare da <strong>punto di accesso¬†e¬†da¬†bilanciatore</strong> alle funzionalit√† dei container che ‚Äúproxa‚Äù. Vediamo quindi chi ‚Äúimplementa‚Äù questi servizi:</p>



<pre>$&gt; docker ps
CONTAINER ID        IMAGE                            COMMAND                  CREATED             STATUS              PORTS                 NAMES
35b70e25a1f3        wordpress:latest                 "docker-entrypoint.s‚Ä¶"   2 minutes ago       Up 2 minutes        80/tcp                wp_wordpress.2.xhpc5jebprigkrhlf742f5272
5aaa08bd0ff9        poc/mysql-for-wordpress:latest   "docker-entrypoint.s‚Ä¶"   22 minutes ago      Up 22 minutes       3306/tcp, 33060/tcp   wp_db.1.uvxb7yhbdu1v36lri90lp2zr8
f0f07649a62e        wordpress:latest                 "docker-entrypoint.s‚Ä¶"   22 minutes ago      Up 22 minutes       80/tcp                wp_wordpress.1.tlobb6t4vnxogbpehwwrr6cyd
</pre>



<p>Con il classico <tt>docker ps</tt> possiamo vedere quali container stanno girando <strong>sul nodo in cui siamo connessi</strong> (occhio a questa cosa!): vediamo infatti che la porta <strong>non viene esposta a livello di container</strong>; possiamo scalarlo tutte le volte che vogliamo: sar√† responsabilit√† del servizio rendere raggiungibili tutti i container <strong>indipendentemente dal nodo in cui sono</strong>.</p>



<p>Quest‚Äôultima considerazione fa sorgere una domanda: in un contesto reale, √® necessario riuscire a far arrivare il traffico <em>da fuori fin dentro il cluster Swarm</em>, per cui √® molto probabile che ci sar√† un bilanciatore davanti. Come si fa quindi a sapere su quale nodo √® stato fatto il binding della porta 8000 in modo da poter raggiungere WordPress? La soluzione che adotta Swarm (ma non solo, anche Kubernetes si comporta cos√¨) √® chiama <strong><a rel="noreferrer noopener" aria-label="Routing Mesh (opens in a new tab)" href="https://docs.docker.com/engine/swarm/ingress/" target="_blank">Routing Mesh</a></strong>: il binding della porta viene fatto su <strong><em>tutti i nodi</em>¬†del¬†cluster</strong>, anche se fisicamente non sta girando un task in quel nodo.</p>



<div class="wp-block-image"><figure class="alignleft is-resized"><amp-img src="../../wp-content/uploads/2019/04/ingress-routing-mesh-1024x456.png" alt="" class="wp-image-17991 amp-wp-enforced-sizes i-amphtml-layout-intrinsic i-amphtml-layout-size-defined" width="512" height="227" srcset="https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-1024x456.png 1024w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-300x134.png 300w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-768x342.png 768w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-150x67.png 150w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-706x315.png 706w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh.png 1129w" layout="intrinsic" i-amphtml-layout="intrinsic"><i-amphtml-sizer class="i-amphtml-sizer"><img alt="" aria-hidden="true" class="i-amphtml-intrinsic-sizer" role="presentation" src="data:image/svg+xml;charset=utf-8,<svg height=&quot;227&quot; width=&quot;512&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;/>"></i-amphtml-sizer><noscript><img src="../../wp-content/uploads/2019/04/ingress-routing-mesh-1024x456.png" alt="" class="wp-image-17991" width="512" height="227" srcset="https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-1024x456.png 1024w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-300x134.png 300w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-768x342.png 768w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-150x67.png 150w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh-706x315.png 706w, https://codingjam.it/wp-content/uploads/2019/04/ingress-routing-mesh.png 1129w" sizes="(max-width: 512px) 100vw, 512px"></noscript></amp-img></figure></div>



<p>Avere chiaro questo semplice concetto credo sia la chiave di volta per pensare quadrimensionalmente e comprendere che ogni operazione che facciamo in Swarm deve tener presente che siamo su un ambiente distribuito.</p>



<h4>Rolling update</h4>



<p>Immaginiamo di dover aggiornare l‚Äôimmagine del MySQL cambiando il numero di connessioni: abbiamo bisogno di <strong>eseguire nuovamente la build</strong> dell‚Äôimmagine. </p>



<p>Su questo Swarm non ci pu√≤ aiutare: abbiamo infatti detto che √® un ambiente di runtime, possibilmente multi-nodo: per lavorare bene dovremmo avere un Docker Registry su cui deployare le nostre immagini (magari generate da Jenkins‚Ä¶) cos√¨ che ogni task potr√† scaricarsi l‚Äôultima versione.</p>



<p>Fatta la legge, trovato l‚Äôinganno: nel caso di studio che stiamo affrontando, siamo <em>su un solo nodo</em>, quindi possiamo rieseguire la build con Docker Compose e aggiornare il servizio Swarm ‚Äúdb‚Äù con la nuova immagine. Ovviamente questo <em>anti pattern</em> √® accettabile solo in ambienti di sviluppo, in altre situazioni √® meglio evitare!</p>



<p>Dopo aver aggiornato l‚Äôimmagine (non voglio sapere come üôÇ ), aggiorniamo anche il servizio: questa volta andr√† forzato (non si accorge dell‚Äôimmagine nuova come Compose):</p>



<pre>$&gt; docker service update --force wp_db
wp_db
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</pre>



<p>Controllando i task, ci accorgiamo che <strong>√® terminato quello precedente e ne √® stato avviato uno nuovo</strong> subito dopo (questo perch√© l'‚Äù<strong>update-order</strong>‚Äù √® di default a ‚Äú<strong>stop-first</strong>‚Äù ‚Äì si pu√≤ verificare con <tt>docker service inspect --pretty wp_db</tt>). A differenza del Compose per√≤, Swarm <strong>non sostituisce</strong> il vecchio container con quello nuovo all‚Äôaggiornamento del servizio, ma ne <strong>crea uno nuovo a fianco</strong>, seguendo la policy dell‚Äôupdate-order. Per fare un vero e proprio <em>rolling update senza downtime</em>, √® possibile specificare l‚Äôorder-update a ‚Äú<strong>start-first</strong>‚Äú: in un dato momento ci saranno cos√¨ contemporaneamente sia il nuovo task che quello vecchio, prima di essere interrotto.</p>



<h3>Tirando le somme</h3>



<p>Ricapitolando quindi, in Swarm c‚Äô√® un cambio di paradigma da tenere sempre presente per capire quello succede: in fase di deploy <strong>chiediamo</strong> (al nodo master) di <strong>creare un servizio</strong> che provoca la <strong>schedulazione di un task</strong> (per replica), su un nodo disponibile, che <strong>gestisce il ciclo di vita di un container</strong>. Eventuali porte pubblicate dal servizio vengono <strong>registrate su tutti </strong>i nodi in modo da poter essere raggiunte dall‚Äôesterno: sar√† cura del servizio di bilanciare il traffico sulle istanze dei nodi che eseguono realmente il task richiesto.</p>



<p>Gli attori principali quindi sono i servizi e i task, non i container, che effettivamente diventano <em>effimeri</em>: possono sparire da un nodo e ricomparire in un altro, per cui non possiamo fare affidamento su eventuali modifiche che vengono fatte internamente al di fuori dei volumi montati (che infatti non andrebbero fatte, ma in sviluppo fa comodo). Inoltre, √® vero che non riavviare mai lo stesso container, ma crearne uno nuovo a fianco, permette un¬†<strong>rollout senza disservizi</strong>¬†(con Compose non era possibile), ma fa proliferare i vecchi container ‚Äúparcheggiati‚Äù (cio√® stoppati) che non verranno pi√π riavviati. Non possiamo quindi fermare un servizio e riavviarlo sperando di ritrovare quelle modifiche fatte nel container precedente, perch√©, anche se ancora l√¨, <strong>non verr√† riavviato</strong>, ma ne verr√† creato uno nuovo.</p>



<p>Inizialmente pensavo fosse ‚Äúsporcizia‚Äù inutile, in realt√†, come¬†<a rel="noreferrer noopener" href="https://github.com/docker/swarmkit/issues/1372" target="_blank">dicono anche gli sviluppatori stessi</a>, le vecchie istanze possono essere usate per diagnostica (mi sono ritrovato davvero in produzione ad aver bisogno di riavviarle per vedere i log!) e comunque non superano mai le 5 istanze (configurabili). In ambiente di sviluppo per√≤ questo non √® di nessuno aiuto, anzi crea solo confusione.</p>



<p>Se alla fine Swarm non vi ha soddisfatto, si pu√≤ sempre disabilitare con:</p>



<pre>
$&gt; docker swarm leave --force
Node left the swarm.
</pre>



<h2>Conclusioni</h2>



<p>Abbiamo quindi visto una panoramica ad ampio spettro (che non vuole essere esaustiva) delle caratteristiche principali di Compose e di Swarm, nonch√© di pregi e difetti.</p>



<p>Il passaggio quindi da Compose a Swarm √® di sola andata? Lo possiamo considerare un upgrade? A mio avviso no: sono due strumenti in parte diversi che rispondono ad esigenze di tipo diverso. Anche se sembra che facciano la stessa cosa, quello che hanno in comune lo fanno in modo diverso, basti pensare alla gestione dei servizi.</p>



<p>Per quanto mi riguarda, continuer√≤ ad usare <strong>Compose in sviluppo</strong> (e su Jenkins): la gestione dei container √® molto semplice e non si ha bisogno di sovrastrutture. Per gli ambienti di <strong>quality</strong> o <strong>produzione</strong> invece √® un‚Äôaltra storia: si pu√≤ trarre vantaggio dal Compose file scritto in sviluppo, tenendo conto delle <em>differenze degli interpreti di Compose e Swarm</em>: sostanzialmente il Compose √® compatibile interamente con la versione 2, mentre Swarm con la 3, anche se qua credo ci sia ancora un gran casino e non √® cos√¨ chiaro. La <a rel="noreferrer noopener" aria-label="matrice di compatibilit√† (opens in a new tab)" href="https://docs.docker.com/compose/compose-file/" target="_blank">matrice di compatibilit√†</a> pu√≤ aiutare a capire.<br><strong>Swarm</strong> credo si comporti bene per <strong>piccoli cluster <em>on premise</em></strong>, dove il numero di nodi non cambia dinamicamente e non ci si attende picchi di traffico anomali. In un contesto B2C, dove il target √® il pubblico di internet e la variabilit√† di traffico √® alta, probabilmente conviene spostarsi su soluzioni cloud autoscalabili: a quel punto Swarm non √® sufficiente e conviene spostarsi su <a rel="noreferrer noopener" aria-label="Kubernetes (opens in a new tab)" href="https://kubernetes.io/" target="_blank">Kubernetes</a>, di gran lunga pi√π complesso ma pi√π potente.</p>



<p></p>
	</div>

	<footer class="amp-wp-article-footer"><div class="amp-wp-meta amp-wp-tax-category">
		Categories: <a href="../../category/devops/index.html" rel="category tag">Devops</a>, <a href="../../category/docker/index.html" rel="category tag">Docker</a>, <a href="../../category/tutorial-2/index.html" rel="category tag">Tutorial</a>	</div>

	<div class="amp-wp-meta amp-wp-tax-tag">
		Tags: <a href="../../tag/docker/index.html" rel="tag">Docker</a>, <a href="../../tag/docker-compose/index.html" rel="tag">docker compose</a>, <a href="../../tag/docker-swarm/index.html" rel="tag">docker swarm</a>, <a href="../../tag/kubernetes/index.html" rel="tag">kubernetes</a>	</div>
		<div class="amp-wp-meta amp-wp-comments-link">
		<a href="../index.html#respond">
			Leave a Comment		</a>
	</div>
	</footer></article><footer class="amp-wp-footer"><div>
		<h2>CodingJam</h2>
		<a href="#top" class="back-to-top">Back to top</a>
	</div>
</footer></body>
<!-- Mirrored from codingjam.it/da-docker-compose-a-docker-swarm-viaggio-di-sola-andata/amp/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 04 Dec 2020 23:50:37 GMT -->
</html>
